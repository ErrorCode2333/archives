【1】类的sizeof： 1.类的大小为类的非静态成员数据的类型大小之和，也就是说静态成员数据不作考虑。
                  2.普通成员函数与sizeof无关。
                  3.虚函数由于要维护在虚函数表，所以要占据一个指针大小，也就是4字节。
                  4.类的总大小也遵守类似class字节对齐的，调整规则。

【2】HTTP会话的四个过程
1. 建立tcp连接
2. 发出请求文档
3. 发出响应文档
4. 释放tcp连接

【3】多态：允许将子类类型的指针赋值给父类类型的指针
【4】顺序表可以采用链式存储或顺序存储

【5】

线程和进程的区别联系：
1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。
2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 
两者都可以提高程序的并发度，提高程序运行效率和响应时间。 
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。
根本区别就一点：用多进程每个进程有自己的地址空间(address space)，线程则共享地址空间。所有其它区别都是由此而来的： 
1、速度：线程产生的速度快，线程间的通讯快、切换快等，因为他们在同一个地址空间内。 
2、资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。 
3、同步问题：线程使用公共变量/内存时需要使用同步机制还是因为他们在同一个地址空间内

【6】拷贝构造函数: CExample(const CExample& C)　就是我们自定义的拷贝构造函数。可见，拷贝构造函数是一种特殊的构造函数，函数的名称必须和类名称一致，它必须的一个参数是本类型的一个引用变量。

【7】不存在基类向派生类的隐式类型转换

【8】数组名永远都不会是指针！ 

【9】一般用const修饰返回值多用于二目操作符重载函数并产生新对象的时候。
【10】const在*左边表示指针指向的是常量，在*右边表示指针本身为常量。
【11】引用，const成员变量，基类构造函数 一定要通过初始化列表来实现。

【12】后缀表达式 用栈。
【13】在计算机中整数用补码形式表示，正数的补码是它本身，负数的补码是原数值除符号位按位取反再加一.

【14】
指针数组 数组指针 指针函数 函数指针

int   *p[4];         //指针数组。  是个有4个元素的数组， 每个元素的是指向整型的指针。(数组的每个元素都是指针)
int   (*p)[4];       //数组指针。 它是一个指针，指向有4个整型元素的数组。                (一个指针指向有4个整型元素的数组)
int *func(void);     //指针函数。 无参函数， 返回整型指针。　　　　　　　　　　　  (函数的返回值为int*)　　　　
int (*func)(void);   //表示函数指针，可以指向无参， 且返回值为整型指针的函数。      (函数的返回值为int)

右左规则：

因为C语言所有复杂的指针声明，都是由各种声明嵌套构成的。如何解读复杂指针声明呢？右左法则是一个既着名又常用的方法。不过，右左法
则其实并不是C标准里面的内容，它是从C标准的声明规定中归纳出来的方法。C标准的声明规则，是用来解决如何创建声明的，而右左法则是用
来解决如何辩识一个声明的，两者可以说是相反的。右左法则的英文原文是这样说的：
The right－left rule: Start reading the declaration from the innermost parentheses, go right, and then go left. When you
encounter parentheses, the direction should be reversed. Once everything in the parentheses has been
parsed, jump out of it. Continue till the whole declaration has been parsed.
这段英文的翻译如下：
右左法则：首先从最里面的圆括号(未定义的标识符)看起，然后往右看，再往左看。每当遇到圆括号时，就应该掉转阅读方向。一旦解析完圆括号里面所有的东西，就跳出圆括号。重复这个过程直到整个声明

解析完毕。
笔者要对这个法则进行一个小小的修正，应该是从未定义的标识符开始阅读，而不是从括号读起，之所以是未定义的标识符，是因为一个声明里面可能有多个标识符，但未定义的标识符只会有一个。
现在通过一些例子来讨论右左法则的应用，先从最简单的开始，逐步加深：
int (*func)(int *p);
首先找到那个未定义的标识符，就是func，它的外面有一对圆括号，而且左边是一个*号，这说明func是一个指针，然后跳出这个圆括号，先看
右边，也是一个圆括号，这说明(*func)是一个函数，而func是一个指向这类函数的指针，就是一个函数指针，这类函数具有int*类型的形参，返回值类型是 int。

【15】基类指针指向派生类对象，如果调用函数是固定偏移量函数，那么还是调用基类版本，如果是调用虚函数，那么根据虚函数表去找。由于每个虚 函数都有一个虚函数列表，并不是直接调用函数，而是通过虚函数列表找到相应的函数的地址，因此根据指向的对象不同，函数地址也将不同，这里将找到对应的子类的fun()函数的地址，

【16】创建进程步骤：
        申请进程块
        为进程分配内存资源
        初始化进程块
        将进程块链入就绪队列

【17】quick sort:
void sort(float array[], int left, int right)
{
    if (left >= right)
        return;

    int low = left;
    int high = right;
    float key = array[low];

    while (low < high)
    {
 
        while ( low < high && array[high] >= key)
        {
            high--;
        }

        array[low] = array[high];

        while (low < high && array[low] <= key)
        {
            low++;
        }

        array[high] = array[low];
    }

    array[low] = key;

    sort(array, left, low - 1);
    sort(array, low + 1, right);
}

【18】int n = scanf("%d%d", &a, &b)，返回值为正确接收输入的参数，当输入Ctrl+d，返回-1 (EOF) while(scanf("%d%d", &a, &b) != EOF)

【19】数组名和指针
　　(1) 数组名作为函数形参时，在函数体内，其失去了本身的内涵，仅仅只是一个指针； 

　　(2) 很遗憾，在失去其内涵的同时，它还失去了其常量特性，可以作自增、自减等操作，可以被修改。 

数组名确实表示指向数组首地址的指针，但这个指针很特别，它的值（指针的值指的是指针所指的地址）不能被改写，能改写的仅仅是其指向的内容，换句话说，数组名只能指向数组的首地址，如果有数组char a[];那么如果出现a = a+1;这是编译都通不过的错误。而对于一个普通的指针是可以的，再比如有数组char a[];那么再定义一个char *p = a;然后再用p = p+1是合法的，这表示让指针p指向&a[1]。

【19】scanf("%s",str)和gets(str)
scanf("%s",str)和gets(str)均可用于输入字符串到字符数组变量str，但scanf("%s",str)只读到输入字符的空格或回车处，而gets(str)

【20】char s[] = "12345"; sizeof(s) = 6 (包括字符串结束符'\0')

【21】
求数组的子数组之和的最大值：一个有N个整数元素的一维数组（A[0]、A[1],...A[n-1])，求子数组之和的最大值。
     1.大体思想，是如果子数组和为负数了，则抛弃现在在算的子数组，以下一个元素为头重新开始计算子数组之和，因为一个数与负数的和肯定会小于这个数本身。时间复杂度为： O(N)
     2.
     方法3：分治法
设A[i]为数组中的一个任意元素，则对于最大连续子数组和，有：
1、若最大子数组和中包括A[i]这个元素，则从A[i]往左找，找出左边的最大值，再从A[i]往右找，找出右边的最大值，相加即得。
2、若最大子数组和中不包括A[i]这个元素，则最大子数组和是A[0],...A[i-1]和A[i+1]...A[n-1]两个子数组最大和的最大值。
时间复杂度为O(NlgN)
int MaxSum3(int *A,int beg,int end)
{
    if(beg==end)
        return A[beg-1];
    int mid = (beg+end)/2;
    int left = MaxSum3(A,beg,mid);
    int right = MaxSum3(A,mid+1,end);
    int sum = A[mid-1];
    int i = mid-1, j = mid+1;
    int maxsum = A[mid-1];
    while(i>=beg)
    {
        sum+= A[i-1];
        if(sum>maxsum)
            maxsum = sum;
        --i;
    }
    sum = maxsum;
    while(j<=end)
    {
        sum+=A[j-1];
        if(sum>maxsum)
            maxsum = sum;
        ++j;
    }
    int max = left>right?left:right;
    max = max>maxsum?max:maxsum;
    return max;
}

【22】串既可以用顺序存储，也可以用链式存储。

【23】函数不能嵌套定义，也就是函数内部不能定义函数。
【24】
面向对象五个基本原则： 
单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。 
开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 
Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。 
依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 
接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口

【25】如果原始类型为unsigned ,进行零扩展，如果原始类型为signed,进行符号位扩展
【26】内联函数是指用inline关键字修饰的函数。在类内定义的函数被默认成内联函数。
定义编辑
内联函数从源代码层看，有函数的结构，而在编译后，却不具备函数的性质。内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处。编译时，类似宏替换，使用函数体替换调用处的函数名。一般在代码中用inline修饰，但是能否形成内联函数，需要看编译器对该函数定义的具体处理。
动机编辑
内联扩展是用来消除函数调用时的时间开销。它通常用于频繁执行的函数。 一个小内存空间的函数非常受益。
如果没有内联函数，编译器可以决定哪些函数内联 。 程序员很少或没有控制哪些只能是内联的，哪些不是。 给这种控制程度，作用是程序员可以选择内联的特定应用 。

【27】static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：double Account::Rate=2.25;static关键字只能用于类定义体内部的声明中，定义时不能标示为static

【28】构造函数初始化时必须采用初始化列表一共有三种情况， 
1.类对象有引用成员
2.需要初始化const修饰的类成员 
3.需要初始化引用成员数据

【28】  char * num = (char *) malloc (10); scanf("%s", num); 指针需要明确地址
【29】fgets(str *, int n, FILE*) 读入n-1个字符.最后补"\0"

【30】这是因为C语言里函数的参数默认是从右往左处理的，输出时是从左往右。
【31】私有继承时基类中各成员属性均变为private，并且基类中private成员被隐藏。派生类的成员也只能访问基类中的public/protected成员，而不能访问private成员；派生类的对象不能访问基类中的任何的成员。(保护继承是所有成员属性变为protected，其他一样)

实例化对象不能访问保护成员和私有成员。

【32】基类指针可以指向派生类的对象（多态性），如果删除该指针delete p；就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。所以，将析构函数声明为虚函数是十分必要的。
【33】虚函数实现：程序运行时就会根据基类对象所获取的派生类对象将派生类对象的VTable和vptr复制给基类，并由基类来调用，从而实现了类成员函数的动态联编。
可见，动态联编时需要指定派生类对象的地址，因而必须通过基类指针或引用对象才能激活虚函数的动态联编机制。

【34】extern ： 1 基本解释：extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。

      也就是说extern有两个作用，第一个,当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$也可能是别的，这要看编译器的"脾气"了(不同的编译器采用的方法不一样)，为什么这么做呢，因为C++支持函数的重载啊，在这里不去过多的论述这个问题，如果你有兴趣可以去网上搜索，相信你可以得到满意的解释!
    第二，当extern不与"C"在一起修饰变量或函数时，如在头文件中: extern int g_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块活其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。
    【35】成员函数后加const
  const对象只能调用const成员函数。
  const对象的值不能被修改，在const成员函数中修改const对象数据成员的值是语法错误
  在const函数中调用非const成员函数是语法错误
  补充：
1。const 只能声名 member function
2。const member function 不能修改对象的任意成员
3。const member function 不能调用非 const member function

【35】  char p[]="hello world";和char *p="hello world"的区别；前者存放在栈里，后者存放在静态区。
【36】栈是向低地址扩展的数据结构，堆是向高地址扩展的数据结构，是不连续的内存区域。
【37】用数组比用指针速度要快一些，因为指针在底层汇编中需要用edx寄存器中转一下，而数组在栈上直接读取。

【38】
SrcImageInfoArray *arr = new SrcImageInfoArray;
SrcImageInfo& info = (*arr)[i];